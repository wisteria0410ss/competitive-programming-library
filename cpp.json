{
    "unionfind": {
        "prefix": "unionfind",
        "description": "競プロ用ライブラリ - unionfind",
        "body": [
            "class unionfind{",
            "    int *tree;",
            "    size_t length;",
            "    size_t root(size_t v){",
            "        if(tree[v] < 0) return v;",
            "        else return tree[v] = root(tree[v]);",
            "    }",
            "public:",
            "    unionfind(size_t n): length(n){",
            "        tree = new int[n];",
            "        for(size_t i=0;i<n;++i) tree[i] = -1;",
            "    }",
            "    size_t count(size_t v){",
            "        return -tree[root(v)];",
            "    }",
            "    bool is_same(size_t u, size_t v){",
            "        return root(u) == root(v);",
            "    }",
            "    bool merge(size_t u, size_t v){",
            "        u = root(u); v = root(v);",
            "        if(u == v) return false;",
            "        if(u > v) std::swap(u, v);",
            "        tree[u] += tree[v];",
            "        tree[v] = u;",
            "        return true;",
            "    }",
            "};"
        ]
    },
    "disjoint-sparse-table": {
        "prefix": "disjoint-sparse-table",
        "description": "競プロ用ライブラリ - disjoint-sparse-table",
        "body": [
            "template <typename Tp, typename Fp>",
            "class disjoint_sparse_table{",
            "    Tp **table;",
            "    Fp func;",
            "    size_t length, lg;",
            "public:",
            "    disjoint_sparse_table(size_t n, Tp *values, Fp f): length(n), func(f){",
            "        lg = CHAR_BIT * sizeof(int) - __builtin_clz(std::max((size_t)1, n-1));",
            "        table  = new Tp*[lg];",
            "        *table = new Tp[n * lg];",
            "        for(int i=1;i<lg;++i) table[i] = *table + n * i;",
            "        for(int i=0;i<n;++i) table[0][i] = values[i];",
            "        for(int s=1;s<lg;++s){",
            "            size_t w = 1<<s;",
            "            for(int i=0;i<n;i+=w<<1){",
            "                size_t l = std::min(i + w, n) - 1, r = i + w;",
            "                table[s][l] = values[l];",
            "                for(int j=l-1;j>=i;--j) table[s][j] = f(values[j], table[s][j+1]);",
            "                if(r >= n) continue;",
            "                table[s][r] = values[r];",
            "                for(int j=r+1;j<r+w && j<n;++j) table[s][j] = f(table[s][j-1], values[j]);",
            "            }",
            "        }",
            "    }",
            "    Tp get(size_t left, size_t right, Tp id=Tp{}){",
            "        if(left >= right || right > length) return id;",
            "        if(left + 1 == right) return table[0][left];",
            "        size_t s = CHAR_BIT * sizeof(int) - __builtin_clz(left ^ --right) - 1;",
            "        return func(table[s][left], table[s][right]);",
            "    }",
            "};"
        ]
    },
    "segment-tree": {
        "prefix": "segment-tree",
        "description": "競プロ用ライブラリ - segment-tree",
        "body": [
            "template <typename Tp, typename Fp>",
            "class segment_tree{",
            "    Tp *tree;",
            "    const size_t len;",
            "    const Tp e;",
            "    const Fp f;",
            "public:",
            "    segment_tree(size_t n, const Tp &id, Fp fn, const Tp *values=nullptr): len(n), e(id), f(fn){",
            "        tree = new Tp[n<<1];",
            "        for(size_t i=0; i<n; ++i) tree[n+i] = values ? values[i] : id;",
            "        for(size_t i=n-1; i>0; --i) tree[i] = fn(tree[i<<1 | 0], tree[i<<1 | 1]);",
            "    }",
            "    void set(size_t pos, const Tp &val){",
            "        tree[pos += len] = val;",
            "        for(pos>>=1; pos>0; pos>>=1){",
            "            tree[pos] = f(tree[pos<<1 | 0], tree[pos<<1 | 1]);",
            "        }",
            "    }",
            "    void add(size_t pos, const Tp &val){",
            "        pos += len;",
            "        tree[pos] = f(val, tree[pos]);",
            "        for(pos>>=1; pos>0; pos>>=1){",
            "            tree[pos] = f(tree[pos<<1 | 0], tree[pos<<1 | 1]);",
            "        }",
            "    }",
            "    Tp get(size_t left, size_t right){",
            "        left += len; right += len;",
            "        Tp lv = e, rv = e;",
            "        while(left < right){",
            "            if(left  & 1) lv = f(lv, tree[left ++]);",
            "            if(right & 1) rv = f(tree[--right], rv);",
            "            left >>= 1; right >>= 1;",
            "        }",
            "        return f(lv, rv);",
            "    }",
            "};"
        ]
    },
    "modint": {
        "prefix": "modint",
        "description": "競プロ用ライブラリ - modint",
        "body": [
            "template <uint32_t mod>",
            "class modint{",
            "    uint64_t value;",
            "public:",
            "    constexpr modint(const int64_t x=0) noexcept: value(x % mod + (x < 0 ? mod : 0)){ }",
            "    constexpr explicit operator uint64_t() const noexcept{ return value; }",
            "    constexpr modint inverse() const noexcept{ return pow(*this, mod-2); }",
            "    constexpr bool operator==(const modint &rhs) const noexcept{ return value == rhs.value; }",
            "    constexpr bool operator!=(const modint &rhs) const noexcept{ return value != rhs.value; }",
            "    constexpr modint operator+() const noexcept{ return modint(*this); }",
            "    constexpr modint operator-() const noexcept{ return modint(mod - value); }",
            "    constexpr modint operator+(const modint &rhs) const noexcept{ return modint(*this) += rhs; }",
            "    constexpr modint operator-(const modint &rhs) const noexcept{ return modint(*this) -= rhs; }",
            "    constexpr modint operator*(const modint &rhs) const noexcept{ return modint(*this) *= rhs; }",
            "    constexpr modint operator/(const modint &rhs) const noexcept{ return modint(*this) /= rhs; }",
            "    constexpr modint &operator+=(const modint &rhs) noexcept{",
            "        if((value += rhs.value) >= mod) value -= mod;",
            "        return *this;",
            "    }",
            "    constexpr modint &operator-=(const modint &rhs) noexcept{ return *this += mod - rhs.value; }",
            "    constexpr modint &operator*=(const modint &rhs) noexcept{",
            "        if((value *= rhs.value) >= mod) value %= mod;",
            "        return *this;",
            "    }",
            "    constexpr modint &operator/=(const modint &rhs) noexcept{ return *this *= rhs.inverse(); }",
            "    constexpr modint operator++(int) noexcept{",
            "        modint ret(*this);",
            "        if((++value) >= mod) value -= mod;",
            "        return ret;",
            "    }",
            "    constexpr modint operator--(int) noexcept{",
            "        modint ret(*this);",
            "        if((value += mod - 1) >= mod) value -= mod;",
            "        return ret;",
            "    }",
            "    constexpr modint &operator++() noexcept{ return *this += 1; }",
            "    constexpr modint &operator--() noexcept{ return *this -= 1; }",
            "    friend std::ostream &operator<<(std::ostream &os, const modint<mod> &x){ return os << x.value; }",
            "    friend std::istream &operator>>(std::istream &is, modint<mod> &x){",
            "        int64_t i;",
            "        is >> i;",
            "        x = modint<mod>(i);",
            "        return is;",
            "    }",
            "    friend constexpr modint<mod> pow(const modint<mod> &x, uint64_t y){",
            "        modint<mod> ret{1}, m{x};",
            "        while(y > 0){",
            "            if(y & 1) ret *= m;",
            "            m *= m;",
            "            y >>= 1;",
            "        }",
            "        return ret;",
            "    }",
            "};"
        ]
    }
}